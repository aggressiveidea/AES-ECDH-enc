\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{float}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\newtheorem{theorem}{Théorème}[section]
\newtheorem{lemma}[theorem]{Lemme}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollaire}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Définition}
\newtheorem{example}[theorem]{Exemple}

\lstset{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4,
    extendedchars=true,
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {É}{{\'E}}1 {î}{{\^i}}1 {è}{{\`e}}1 {à}{{\`a}}1 {â}{{\^a}}1
}

\chapter*{Rapport de Projet : Système Cryptographique Hybride AES-ECDH}
\setcounter{chapter}{1}
\addcontentsline{toc}{chapter}{Système Cryptographique Hybride AES-ECDH}

\section{Introduction Générale}

Dans le domaine de la sécurité informatique, la protection des données repose sur des piliers mathématiques robustes issus de l'algèbre abstraite. Ce projet explore la synergie entre la cryptographie symétrique (AES) et asymétrique (ECDH) en s'appuyant sur deux structures algébriques fondamentales : les corps finis de Galois et les groupes de points sur courbes elliptiques.

L'objectif central est de concevoir un système où la couche de substitution (S-box) de l'AES n'est plus statique, mais générée dynamiquement à partir d'un polynôme irréductible personnalisé dans le corps de Galois $GF(2^8)$, démontrant ainsi la flexibilité et la profondeur des fondements algébriques de la cryptographie moderne.

\section{Fondements Algébriques Purs}

\subsection{Structures Algébriques Fondamentales}

\subsubsection{Groupes}

\begin{definition}[Groupe]
Un ensemble $G$ muni d'une loi de composition interne $\star : G \times G \to G$ forme un \textbf{groupe} $(G, \star)$ si les axiomes suivants sont satisfaits :
\begin{enumerate}
    \item \textbf{Associativité} : $\forall a, b, c \in G, \quad (a \star b) \star c = a \star (b \star c)$
    \item \textbf{Élément neutre} : $\exists e \in G, \forall a \in G, \quad e \star a = a \star e = a$
    \item \textbf{Inverse} : $\forall a \in G, \exists a^{-1} \in G, \quad a \star a^{-1} = a^{-1} \star a = e$
\end{enumerate}
Si de plus $\forall a, b \in G, a \star b = b \star a$, le groupe est dit \textbf{abélien} ou \textbf{commutatif}.
\end{definition}

\begin{example}
Dans notre contexte cryptographique :
\begin{itemize}
    \item $(\mathbb{Z}_n^*, \times)$ forme un groupe multiplicatif pour $n$ premier
    \item L'ensemble des points d'une courbe elliptique avec l'addition géométrique forme un groupe abélien
\end{itemize}
\end{example}

\begin{theorem}[Lagrange]
Soit $G$ un groupe fini et $H$ un sous-groupe de $G$. Alors l'ordre de $H$ divise l'ordre de $G$ :
\[|H| \mid |G|\]
\end{theorem}

\subsubsection{Anneaux et Corps}

\begin{definition}[Anneau]
Un ensemble $A$ muni de deux lois de composition interne $+$ et $\times$ forme un \textbf{anneau} $(A, +, \times)$ si :
\begin{enumerate}
    \item $(A, +)$ est un groupe abélien
    \item $\times$ est associative
    \item $\times$ est distributive par rapport à $+$ : $a \times (b + c) = (a \times b) + (a \times c)$
\end{enumerate}
Si $\times$ est commutative, l'anneau est dit \textbf{commutatif}. S'il existe un élément neutre pour $\times$, l'anneau est dit \textbf{unitaire}.
\end{definition}

\begin{definition}[Corps]
Un anneau commutatif unitaire $(K, +, \times)$ est un \textbf{corps} si tout élément non nul possède un inverse multiplicatif :
\[\forall a \in K \setminus \{0\}, \exists a^{-1} \in K, \quad a \times a^{-1} = 1\]
\end{definition}

\begin{theorem}[Caractéristique d'un corps]
La caractéristique d'un corps $K$, notée $\text{char}(K)$, est le plus petit entier $p > 0$ tel que :
\[\underbrace{1 + 1 + \cdots + 1}_{p \text{ fois}} = 0\]
Si un tel $p$ n'existe pas, $\text{char}(K) = 0$. Pour un corps fini, la caractéristique est toujours un nombre premier.
\end{theorem}

\subsection{Corps Finis et Théorie de Galois}

\subsubsection{Construction des Corps Finis}

\begin{theorem}[Existence et Unicité]
Pour tout nombre premier $p$ et tout entier $n \geq 1$, il existe un corps fini à $p^n$ éléments, unique à isomorphisme près, noté $GF(p^n)$ ou $\mathbb{F}_{p^n}$.
\end{theorem}

\begin{proof}[Esquisse]
Le corps $GF(p^n)$ peut être construit comme le corps de décomposition du polynôme $X^{p^n} - X$ sur $\mathbb{F}_p$. Alternativement, on peut le construire comme $\mathbb{F}_p[X]/(P(X))$ où $P(X)$ est un polynôme irréductible de degré $n$ sur $\mathbb{F}_p$.
\end{proof}

\subsubsection{Structure de $GF(2^8)$}

Dans notre implémentation AES, nous travaillons dans $GF(2^8) = \mathbb{F}_2[X]/(P(X))$ où $P(X)$ est un polynôme irréductible de degré 8.

\begin{definition}[Polynôme Irréductible]
Un polynôme $P(X) \in \mathbb{F}_p[X]$ est \textbf{irréductible} sur $\mathbb{F}_p$ s'il n'est pas constant et ne peut être factorisé en produit de polynômes de degré strictement inférieur sur $\mathbb{F}_p$.
\end{definition}

\begin{example}[Polynômes Irréductibles de Degré 8 sur $\mathbb{F}_2$]
Les polynômes suivants sont irréductibles et utilisables pour construire $GF(2^8)$ :
\begin{align*}
P_1(X) &= X^8 + X^4 + X^3 + X + 1 \quad &\text{(0x11B, standard AES)} \\
P_2(X) &= X^8 + X^4 + X^3 + X^2 + 1 \quad &\text{(0x11D, utilisé dans ce projet)} \\
P_3(X) &= X^8 + X^6 + X^3 + X^2 + 1 \quad &\text{(0x14D)} \\
P_4(X) &= X^8 + X^6 + X^5 + X^2 + 1 \quad &\text{(0x165)}
\end{align*}
\end{example}

\subsubsection{Opérations dans $GF(2^8)$}

\begin{proposition}[Addition]
L'addition dans $GF(2^8)$ correspond à l'addition polynomiale modulo 2, équivalente à l'opération XOR bit à bit :
\[\forall a, b \in GF(2^8), \quad a + b = a \oplus b\]
\end{proposition}

\begin{proposition}[Multiplication]
La multiplication dans $GF(2^8)$ est définie par :
\[a \times b = (a \cdot b) \mod P(X)\]
où $\cdot$ désigne la multiplication polynomiale standard et $\mod P(X)$ la réduction modulo le polynôme irréductible.
\end{proposition}

\begin{theorem}[Structure Multiplicative]
Le groupe multiplicatif $GF(2^8)^* = GF(2^8) \setminus \{0\}$ est cyclique d'ordre 255. Il existe donc un élément générateur $g$ tel que :
\[GF(2^8)^* = \{g^0, g^1, g^2, \ldots, g^{254}\}\]
\end{theorem}

\subsubsection{Implémentation : Arithmétique dans $GF(2^8)$}

\begin{lstlisting}[language=Python, caption=Classe GF256 : Multiplication dans $GF(2^8)$]
class GF256:
    """Arithmétique dans GF(2^8) avec polynôme irréductible personnalisé."""
    def __init__(self, poly=0x11D):
        self.poly = poly

    def multiply(self, a, b):
        """Multiplication de deux éléments dans GF(2^8)."""
        p = 0
        for _ in range(8):
            if b & 1:
                p ^= a
            hi_bit = a & 0x80
            a <<= 1
            if hi_bit:
                a ^= self.poly  # Réduction modulo P(X)
            a &= 0xFF
            b >>= 1
        return p
\end{lstlisting}

\subsubsection{Inversion dans $GF(2^8)$}

\begin{theorem}[Petit Théorème de Fermat pour Corps Finis]
Pour tout élément $a \in GF(2^8)^*$, on a :
\[a^{255} = 1 \implies a^{-1} = a^{254}\]
\end{theorem}

\begin{proof}
Le groupe multiplicatif $GF(2^8)^*$ est d'ordre 255. Par le théorème de Lagrange, pour tout $a \in GF(2^8)^*$, l'ordre de $a$ divise 255, donc $a^{255} = 1$. En multipliant par $a^{-1}$, on obtient $a^{254} = a^{-1}$.
\end{proof}

Cette propriété permet un calcul efficace de l'inverse par exponentiation rapide :
\[a^{254} = a^{128} \cdot a^{64} \cdot a^{32} \cdot a^{16} \cdot a^{8} \cdot a^{4} \cdot a^{2}\]

\begin{lstlisting}[language=Python, caption=Inversion dans $GF(2^8)$ : Méthode par Exponentiation]
def inverse(self, n):
    """Calcule l'inverse multiplicatif via a^254."""
    if n == 0:
        return 0
    res = 1
    curr = n
    for i in range(1, 8):  # i=1 to 7
        curr = self.multiply(curr, curr)  # n^2, n^4, ..., n^128
        res = self.multiply(res, curr)
    return res
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Inversion dans $GF(2^8)$ : Algorithme d'Euclide Étendu]
def extended_gcd(self, a):
    """Calcule l'inverse via l'algorithme d'Euclide étendu."""
    if a == 0: return 0
    r0, r1 = self.poly | 0x100, a
    s0, s1 = 0, 1
    while r1 != 0:
        shift = r0.bit_length() - r1.bit_length()
        if shift < 0:
            r0, r1 = r1, r0
            s0, s1 = s1, s0
            continue
        r0 ^= (r1 << shift)
        s0 ^= (s1 << shift)
        if r0.bit_length() < r1.bit_length():
            r0, r1 = r1, r0
            s0, s1 = s1, s0
    return s0 & 0xFF
\end{lstlisting}

\subsection{Géométrie Algébrique : Courbes Elliptiques}

\subsubsection{Définition et Propriétés}

\begin{definition}[Courbe Elliptique sur un Corps]
Soit $K$ un corps de caractéristique différente de 2 et 3. Une \textbf{courbe elliptique} sur $K$ est l'ensemble des points $(x, y) \in K^2$ satisfaisant l'équation de Weierstrass :
\[E : y^2 = x^3 + ax + b\]
où $a, b \in K$ et $\Delta = -16(4a^3 + 27b^2) \neq 0$ (condition de non-singularité), augmenté d'un point à l'infini $\mathcal{O}$.
\end{definition}

\begin{theorem}[Structure de Groupe]
L'ensemble des points d'une courbe elliptique $E(K)$ muni de la loi d'addition géométrique forme un groupe abélien avec $\mathcal{O}$ comme élément neutre.
\end{theorem}

\subsubsection{Loi d'Addition Géométrique}

Pour deux points $P = (x_1, y_1)$ et $Q = (x_2, y_2)$ sur $E$, le point $R = P + Q = (x_3, y_3)$ est défini par :

\begin{align*}
\lambda &= \begin{cases}
\dfrac{y_2 - y_1}{x_2 - x_1} & \text{si } P \neq Q \\[0.5em]
\dfrac{3x_1^2 + a}{2y_1} & \text{si } P = Q
\end{cases} \\[1em]
x_3 &= \lambda^2 - x_1 - x_2 \\
y_3 &= \lambda(x_1 - x_3) - y_1
\end{align*}

\begin{proposition}[Propriétés de l'Addition]
\begin{enumerate}
    \item $P + \mathcal{O} = \mathcal{O} + P = P$ (élément neutre)
    \item $P + (-P) = \mathcal{O}$ où $-P = (x_P, -y_P)$ (inverse)
    \item $(P + Q) + R = P + (Q + R)$ (associativité)
    \item $P + Q = Q + P$ (commutativité)
\end{enumerate}
\end{proposition}

\subsubsection{Implémentation : Opérations sur Courbes Elliptiques}

\begin{lstlisting}[language=Python, caption=Classe ECC : Addition de Points]
class ECC:
    """Opérations sur courbes elliptiques y^2 = x^3 + ax + b (mod p)."""
    def __init__(self, a, b, p):
        self.a = a
        self.b = b
        self.p = p

    def add(self, P, Q):
        """Addition de deux points sur la courbe elliptique."""
        if P is None: return Q
        if Q is None: return P
        x1, y1 = P
        x2, y2 = Q
        
        # Cas particulier : P + (-P) = O
        if x1 == x2 and (y1 + y2) % self.p == 0:
            return None
            
        # Calcul de la pente lambda
        if x1 == x2 and y1 == y2:
            # Doublement de point
            m = (3 * x1**2 + self.a) * pow(2 * y1, -1, self.p)
        else:
            # Addition de points distincts
            m = (y2 - y1) * pow(x2 - x1, -1, self.p)
            
        # Calcul du point résultant
        x3 = (m**2 - x1 - x2) % self.p
        y3 = (m * (x1 - x3) - y1) % self.p
        return (x3, y3)
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Multiplication Scalaire : Algorithme Double-and-Add]
def multiply(self, k, P):
    """Multiplication scalaire : kP (méthode double-and-add)."""
    res = None
    base = P
    while k > 0:
        if k & 1:
            res = self.add(res, base)
        base = self.add(base, base)
        k >>= 1
    return res
\end{lstlisting}

\subsubsection{Courbes Elliptiques sur Corps Finis}

\begin{theorem}[Hasse]
Soit $E$ une courbe elliptique définie sur $\mathbb{F}_q$. Le nombre de points $\#E(\mathbb{F}_q)$ satisfait :
\[|q + 1 - \#E(\mathbb{F}_q)| \leq 2\sqrt{q}\]
\end{theorem}

\begin{example}[Notre Courbe sur $\mathbb{F}_{17}$]
Pour la courbe $E : y^2 = x^3 + 2x + 2$ sur $\mathbb{F}_{17}$, nous avons :
\begin{itemize}
    \item Point générateur : $G = (5, 1)$
    \item Ordre du groupe : $\#E(\mathbb{F}_{17}) = 19$ (incluant $\mathcal{O}$)
    \item Ordre de $G$ : $\text{ord}(G) = 19$ (générateur du groupe)
\end{itemize}
La borne de Hasse donne : $|17 + 1 - 19| = 1 \leq 2\sqrt{17} \approx 8.25$ ✓
\end{example}

\subsection{Problèmes Difficiles en Cryptographie}

\subsubsection{Logarithme Discret}

\begin{definition}[Problème du Logarithme Discret (DLP)]
Soit $G$ un groupe cyclique d'ordre $n$ et $g$ un générateur de $G$. Étant donné $h \in G$, le problème du logarithme discret consiste à trouver $x \in \mathbb{Z}_n$ tel que :
\[g^x = h\]
\end{definition}

\begin{definition}[Problème du Logarithme Discret sur Courbes Elliptiques (ECDLP)]
Soit $E$ une courbe elliptique sur un corps fini et $P$ un point d'ordre $n$. Étant donné $Q \in \langle P \rangle$, trouver $k \in \mathbb{Z}_n$ tel que :
\[kP = Q\]
\end{definition}

\begin{theorem}[Complexité]
Pour un groupe de taille $n$ :
\begin{itemize}
    \item DLP classique : $O(\sqrt{n})$ avec l'algorithme Baby-step Giant-step
    \item ECDLP : $O(\sqrt{n})$ (meilleur algorithme connu, méthode de Pollard rho)
\end{itemize}
Cependant, pour une sécurité équivalente, les courbes elliptiques nécessitent des clés beaucoup plus courtes (256 bits vs 3072 bits pour RSA).
\end{theorem}

\section{Architecture Mathématique du Système AES-ECDH}

\subsection{Advanced Encryption Standard (AES) : Fondements Algébriques}

\subsubsection{Structure Globale}

L'AES opère sur des blocs de 128 bits organisés en une matrice $4 \times 4$ d'octets appelée \textbf{state}. Chaque octet est interprété comme un élément de $GF(2^8)$.

\begin{definition}[Round AES]
Un round AES (sauf le dernier) consiste en quatre transformations :
\begin{enumerate}
    \item \textbf{SubBytes} : Substitution non-linéaire via la S-box
    \item \textbf{ShiftRows} : Permutation des lignes
    \item \textbf{MixColumns} : Transformation linéaire dans $GF(2^8)$
    \item \textbf{AddRoundKey} : XOR avec la sous-clé de round
\end{enumerate}
\end{definition}

\subsubsection{Construction de la S-Box}

\begin{theorem}[Propriétés de la S-Box AES]
La S-box de l'AES est construite pour maximiser :
\begin{itemize}
    \item La \textbf{non-linéarité} : résistance à la cryptanalyse linéaire
    \item La \textbf{confusion} : chaque bit de sortie dépend de manière complexe de chaque bit d'entrée
\end{itemize}
\end{theorem}

La construction se fait en deux étapes :

\textbf{Étape 1 : Inversion dans $GF(2^8)$}
\[S_1(x) = \begin{cases} x^{-1} & \text{si } x \neq 0 \\ 0 & \text{si } x = 0 \end{cases}\]

\textbf{Étape 2 : Transformation Affine}

Soit $b = (b_7, b_6, \ldots, b_0)$ la représentation binaire de $S_1(x)$. La transformation affine est :
\[b'_i = b_i \oplus b_{(i+4) \bmod 8} \oplus b_{(i+5) \bmod 8} \oplus b_{(i+6) \bmod 8} \oplus b_{(i+7) \bmod 8} \oplus c_i\]
où $c = (01100011)_2 = 0x63$.

En notation matricielle sur $GF(2)$ :
\[\begin{pmatrix} b'_0 \\ b'_1 \\ b'_2 \\ b'_3 \\ b'_4 \\ b'_5 \\ b'_6 \\ b'_7 \end{pmatrix} = 
\begin{pmatrix}
1 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\
1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 \\
1 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\
1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 1 & 1 & 1 & 1 & 1
\end{pmatrix}
\begin{pmatrix} b_0 \\ b_1 \\ b_2 \\ b_3 \\ b_4 \\ b_5 \\ b_6 \\ b_7 \end{pmatrix} \oplus
\begin{pmatrix} 1 \\ 1 \\ 0 \\ 0 \\ 0 \\ 1 \\ 1 \\ 0 \end{pmatrix}\]

\subsubsection{Implémentation : Génération de la S-Box}

\begin{lstlisting}[language=Python, caption=Construction de la S-Box Dynamique]
class SBoxGenerator:
    def __init__(self, poly=0x11D):
        self.gf = GF256(poly)
        self.sbox = self._generate_sbox()
        self.inv_sbox = self._generate_inv_sbox()

    def _generate_sbox(self):
        """Génère la S-box : inversion + transformation affine."""
        sbox = [0] * 256
        for i in range(256):
            # Étape 1 : Inversion dans GF(2^8)
            inv = self.gf.inverse(i)
            
            # Étape 2 : Transformation affine
            x = inv
            res = 0x63  # Constante c
            for _ in range(5):
                res ^= x
                x = ((x << 1) | (x >> 7)) & 0xFF
            sbox[i] = res
        return sbox

    def _generate_inv_sbox(self):
        """Génère la S-box inverse."""
        inv = [0] * 256
        for i, val in enumerate(self.sbox):
            inv[val] = i
        return inv
\end{lstlisting}

\subsubsection{MixColumns : Multiplication Matricielle dans $GF(2^8)$}

\begin{definition}[Transformation MixColumns]
Chaque colonne du state est multipliée par une matrice circulante fixe dans $GF(2^8)$ :
\[\begin{pmatrix} s'_0 \\ s'_1 \\ s'_2 \\ s'_3 \end{pmatrix} = 
\begin{pmatrix}
02 & 03 & 01 & 01 \\
01 & 02 & 03 & 01 \\
01 & 01 & 02 & 03 \\
03 & 01 & 01 & 02
\end{pmatrix}
\begin{pmatrix} s_0 \\ s_1 \\ s_2 \\ s_3 \end{pmatrix}\]
où les multiplications et additions se font dans $GF(2^8)$.
\end{definition}

\begin{proposition}[Inversibilité]
La matrice MixColumns est inversible dans $GF(2^8)^{4 \times 4}$, garantissant la réversibilité de l'opération.
\end{proposition}

\begin{lstlisting}[language=Python, caption=Implémentation de MixColumns]
def _mix_columns(self, state):
    for i in range(0, 16, 4):
        c0, c1, c2, c3 = state[i:i+4]
        state[i]   = self.gf.multiply(0x02, c0) ^ self.gf.multiply(0x03, c1) ^ c2 ^ c3
        state[i+1] = c0 ^ self.gf.multiply(0x02, c1) ^ self.gf.multiply(0x03, c2) ^ c3
        state[i+2] = c0 ^ c1 ^ self.gf.multiply(0x02, c2) ^ self.gf.multiply(0x03, c3)
        state[i+3] = self.gf.multiply(0x03, c0) ^ c1 ^ c2 ^ self.gf.multiply(0x02, c3)
    return state
\end{lstlisting}

\subsubsection{Génération Dynamique des Round Constants}

\begin{theorem}[Cohérence Algébrique]
Pour maintenir la cohérence mathématique lorsque le polynôme irréductible $P(X)$ change, les constantes de round $\text{Rcon}[i]$ doivent être calculées dans le même corps $GF(2^8)$ :
\[\text{Rcon}[i] = x^{i-1} \mod P(X), \quad i = 1, 2, \ldots, 10\]
où $x$ représente le polynôme $X$ dans $GF(2^8)$, soit $0x02$ en notation hexadécimale.
\end{theorem}

\begin{lstlisting}[language=Python, caption=Génération Dynamique des Constantes de Round]
def _get_rcon(self):
    """Génère les constantes de round dynamiquement."""
    rcon = []
    curr = 0x01
    for _ in range(10):
        rcon.append(curr)
        curr = self.gf.multiply(curr, 0x02)  # x^i mod P(X)
    return rcon
\end{lstlisting}

\subsubsection{Implémentation Complète : AES Personnalisé}

\begin{lstlisting}[language=Python, caption=Chiffrement AES avec Visualisation des Étapes]
class CustomAES:
    def __init__(self, sbox_gen):
        self.sbox = sbox_gen.sbox
        self.inv_sbox = sbox_gen.inv_sbox
        self.gf = sbox_gen.gf

    def encrypt_block_with_steps(self, block, key_bytes):
        """Chiffre un bloc et retourne toutes les étapes intermédiaires."""
        round_keys = self.key_expansion(key_bytes)
        steps = []
        
        state = list(block)
        steps.append(("Initial State", bytes(state)))
        
        state = self._add_round_key(state, round_keys[0])
        steps.append(("Initial AddRoundKey", bytes(state)))
        
        for i in range(1, 10):
            state = self._sub_bytes(state)
            steps.append((f"Round {i} - SubBytes", bytes(state)))
            state = self._shift_rows(state)
            steps.append((f"Round {i} - ShiftRows", bytes(state)))
            state = self._mix_columns(state)
            steps.append((f"Round {i} - MixColumns", bytes(state)))
            state = self._add_round_key(state, round_keys[i])
            steps.append((f"Round {i} - AddRoundKey", bytes(state)))
            
        state = self._sub_bytes(state)
        steps.append(("Round 10 - SubBytes", bytes(state)))
        state = self._shift_rows(state)
        steps.append(("Round 10 - ShiftRows", bytes(state)))
        state = self._add_round_key(state, round_keys[10])
        steps.append(("Final Ciphertext", bytes(state)))
        
        return steps
\end{lstlisting}

\subsection{Protocole ECDH : Échange de Clés Diffie-Hellman sur Courbes Elliptiques}

\subsubsection{Principe Mathématique}

\begin{theorem}[Sécurité d'ECDH]
La sécurité du protocole ECDH repose sur la difficulté du problème ECDLP. Si Alice et Bob génèrent respectivement les clés privées $a$ et $b$, et les clés publiques $A = aG$ et $B = bG$, alors :
\[S = aB = a(bG) = (ab)G = b(aG) = bA\]
Un attaquant connaissant $G$, $A$ et $B$ ne peut calculer $S$ efficacement sans résoudre ECDLP.
\end{theorem}

\subsubsection{Dérivation de Clé Cryptographique}

Le secret partagé $S = (x_S, y_S)$ est un point de la courbe. Pour obtenir une clé AES de 128 bits, on utilise une fonction de hachage cryptographique :
\[K_{AES} = \text{SHA-256}(x_S \| y_S)[0:16]\]
où $\|$ désigne la concaténation et $[0:16]$ extrait les 16 premiers octets.

\subsubsection{Implémentation : Protocole ECDH Complet}

\begin{lstlisting}[language=Python, caption=Échange de Clés ECDH et Utilisation]
import hashlib

# Configuration de la courbe
ecc = ECC(a=2, b=2, p=17)
G = (5, 1)  # Point générateur

# Alice génère sa paire de clés
alice_priv = 5
alice_pub = ecc.multiply(alice_priv, G)

# Bob génère sa paire de clés
bob_priv = 7
bob_pub = ecc.multiply(bob_priv, G)

# Calcul du secret partagé
shared_alice = ecc.multiply(alice_priv, bob_pub)
shared_bob = ecc.multiply(bob_priv, alice_pub)

assert shared_alice == shared_bob  # Vérification

# Dérivation de la clé AES
shared_bytes = f"{shared_alice[0]},{shared_alice[1]}".encode()
aes_key = hashlib.sha256(shared_bytes).digest()[:16]

# Utilisation pour chiffrement
sbox_gen = SBoxGenerator(poly=0x11D)
aes = CustomAES(sbox_gen)

plaintext = b"Message secret!!"
ciphertext = aes.encrypt_block(plaintext, aes_key)
decrypted = aes.decrypt_block(ciphertext, aes_key)
\end{lstlisting}

\section{Analyse de Complexité et Résultats}

\subsection{Complexité Algorithmique}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|l|}
\hline
\textbf{Opération} & \textbf{Complexité} & \textbf{Contexte} & \textbf{Justification} \\
\hline
Multiplication GF & $O(m)$ & AES / MixColumns & 8 itérations pour $m=8$ \\
Inversion GF & $O(m^2)$ & Génération S-box & 7 multiplications carrées \\
Addition ECC & $O(\log p)$ & Échange de clés & Inversion modulaire \\
Mult. Scalaire ECC & $O(\log k \cdot \log p)$ & ECDH & Double-and-add \\
Round AES & $O(1)$ & Chiffrement & Opérations sur 16 octets \\
Encryption AES & $O(N_{rounds})$ & Chiffrement complet & 10 rounds pour AES-128 \\
\hline
\end{tabular}
\caption{Complexité des opérations cryptographiques}
\end{table}

\subsection{Résultats de Validation}

Le système a été testé avec succès sur 100 itérations pour chacun des polynômes irréductibles suivants :
\begin{itemize}
    \item 0x11B (standard AES)
    \item 0x11D (utilisé dans ce projet)
    \item 0x14D
    \item 0x165
\end{itemize}

Pour chaque polynôme, la propriété $\text{decrypt}(\text{encrypt}(M)) = M$ a été vérifiée avec 100\% de succès.

\subsection{Interface Utilisateur Streamlit}

L'application web permet :
\begin{enumerate}
    \item \textbf{Visualisation ECDH} : Génération interactive des clés publiques et calcul du secret partagé
    \item \textbf{Analyse S-Box} : Comparaison entre la S-box personnalisée et celle du standard AES
    \item \textbf{Chiffrement Interactif} : Visualisation des états intermédiaires à chaque round
    \item \textbf{Analyse Mathématique} : Graphique des points de la courbe elliptique sur $\mathbb{F}_{17}$
\end{enumerate}

\section{Conclusion}

Ce projet démontre la profondeur et la flexibilité des structures algébriques dans la cryptographie moderne. En combinant :
\begin{itemize}
    \item La théorie des corps finis de Galois pour l'AES
    \item La géométrie algébrique des courbes elliptiques pour ECDH
    \item Une implémentation Python rigoureuse et pédagogique
\end{itemize}

nous avons créé un système hybride qui illustre comment l'algèbre abstraite se traduit en sécurité concrète. L'utilisation d'une S-box dynamique basée sur un polynôme irréductible personnalisable offre une flexibilité unique tout en maintenant les propriétés cryptographiques essentielles de non-linéarité et de confusion.

Ce travail constitue à la fois un outil pédagogique pour comprendre les fondements mathématiques de la cryptographie et une démonstration pratique de l'implémentation de primitives cryptographiques robustes.
